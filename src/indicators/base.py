"""
Base Indicator Framework

Provides abstract base class for all technical indicators.
Supports multi-timeframe calculation and signal generation.
"""
from abc import ABC, abstractmethod
from dataclasses import dataclass, field
from enum import Enum
from typing import Optional, Dict, Any, List

import pandas as pd


class SignalType(Enum):
    """Types of indicator signals."""
    BULLISH = "bullish"
    BEARISH = "bearish"
    NEUTRAL = "neutral"
    FLIP_BULLISH = "flip_bullish"  # Just flipped from bearish to bullish
    FLIP_BEARISH = "flip_bearish"  # Just flipped from bullish to bearish


@dataclass
class IndicatorSignal:
    """
    Signal generated by an indicator.
    
    Attributes:
        signal_type: Type of signal (bullish, bearish, etc.)
        value: Primary indicator value
        strength: Signal strength (0.0 to 1.0)
        metadata: Additional indicator-specific data
    """
    signal_type: SignalType
    value: float
    strength: float = 0.5
    metadata: Dict[str, Any] = field(default_factory=dict)
    
    @property
    def is_bullish(self) -> bool:
        return self.signal_type in (SignalType.BULLISH, SignalType.FLIP_BULLISH)
    
    @property
    def is_bearish(self) -> bool:
        return self.signal_type in (SignalType.BEARISH, SignalType.FLIP_BEARISH)
    
    @property
    def is_flip(self) -> bool:
        return self.signal_type in (SignalType.FLIP_BULLISH, SignalType.FLIP_BEARISH)


class Indicator(ABC):
    """
    Abstract base class for technical indicators.
    
    All indicators must implement:
    - calculate(): Compute indicator values from OHLCV data
    - get_signal(): Generate trading signal from current state
    
    Indicators should be stateless - all state is derived from input data.
    """
    
    def __init__(self, name: str, **params):
        """
        Initialize indicator with parameters.
        
        Args:
            name: Unique name for this indicator instance
            **params: Indicator-specific parameters
        """
        self.name = name
        self.params = params
    
    @abstractmethod
    def calculate(self, data: pd.DataFrame) -> pd.DataFrame:
        """
        Calculate indicator values from OHLCV data.
        
        Args:
            data: DataFrame with columns [open, high, low, close, volume]
                  Index should be datetime
        
        Returns:
            DataFrame with indicator columns added
        """
        pass
    
    @abstractmethod
    def get_signal(self, data: pd.DataFrame) -> IndicatorSignal:
        """
        Generate trading signal from current indicator state.
        
        Args:
            data: DataFrame with indicator values (from calculate())
        
        Returns:
            IndicatorSignal with current signal and metadata
        """
        pass
    
    def get_value(self, data: pd.DataFrame, column: Optional[str] = None) -> float:
        """
        Get the latest indicator value.
        
        Args:
            data: DataFrame with indicator values
            column: Specific column to return (defaults to primary value)
        
        Returns:
            Latest indicator value
        """
        if data.empty:
            return 0.0
        
        col = column or f"{self.name}_value"
        if col in data.columns:
            return float(data[col].iloc[-1])
        return 0.0
    
    def validate_data(self, data: pd.DataFrame) -> bool:
        """
        Validate input data has required columns.
        
        Args:
            data: Input DataFrame
        
        Returns:
            True if valid
        """
        required = ["open", "high", "low", "close", "volume"]
        return all(col in data.columns for col in required) and len(data) > 0
    
    def __repr__(self):
        params_str = ", ".join(f"{k}={v}" for k, v in self.params.items())
        return f"{self.__class__.__name__}({self.name}, {params_str})"


class CompositeIndicator(Indicator):
    """
    Indicator that combines multiple sub-indicators.
    
    Useful for creating complex indicators from simpler components.
    """
    
    def __init__(self, name: str, indicators: List[Indicator], **params):
        """
        Initialize composite indicator.
        
        Args:
            name: Unique name
            indicators: List of sub-indicators
            **params: Additional parameters
        """
        super().__init__(name, **params)
        self.indicators = indicators
    
    def calculate(self, data: pd.DataFrame) -> pd.DataFrame:
        """Calculate all sub-indicators."""
        result = data.copy()
        for indicator in self.indicators:
            result = indicator.calculate(result)
        return result
    
    def get_signal(self, data: pd.DataFrame) -> IndicatorSignal:
        """
        Combine signals from sub-indicators.
        
        Override this method to implement custom signal logic.
        Default: Average of all signals.
        """
        signals = [ind.get_signal(data) for ind in self.indicators]
        
        # Count bullish/bearish
        bullish = sum(1 for s in signals if s.is_bullish)
        bearish = sum(1 for s in signals if s.is_bearish)
        
        # Average value and strength
        avg_value = sum(s.value for s in signals) / len(signals) if signals else 0
        avg_strength = sum(s.strength for s in signals) / len(signals) if signals else 0.5
        
        if bullish > bearish:
            signal_type = SignalType.BULLISH
        elif bearish > bullish:
            signal_type = SignalType.BEARISH
        else:
            signal_type = SignalType.NEUTRAL
        
        return IndicatorSignal(
            signal_type=signal_type,
            value=avg_value,
            strength=avg_strength,
            metadata={"sub_signals": [s.signal_type.value for s in signals]}
        )
