"""
Base Strategy Framework

Provides abstract base class for trading strategies.
Strategies combine indicator signals to generate trade decisions.
"""
from abc import ABC, abstractmethod
from dataclasses import dataclass, field
from enum import Enum
from typing import Optional, Dict, Any, List

from src.indicators import IndicatorManager, IndicatorSignal


class ActionType(Enum):
    """Types of trading actions."""
    BUY = "buy"
    SELL = "sell"
    HOLD = "hold"


@dataclass
class StrategySignal:
    """
    Signal generated by a strategy.
    
    Attributes:
        action: Trading action (buy, sell, hold)
        strength: Signal strength (0.0 to 1.0)
        asset: Asset symbol
        reason: Human-readable reason for the signal
        indicators: Snapshot of indicator values that triggered this signal
        metadata: Additional strategy-specific data
    """
    action: ActionType
    strength: float
    asset: str
    reason: str
    indicators: Dict[str, Any] = field(default_factory=dict)
    metadata: Dict[str, Any] = field(default_factory=dict)
    
    @property
    def is_trade(self) -> bool:
        """Returns True if this signal is a trade (not hold)."""
        return self.action in (ActionType.BUY, ActionType.SELL)
    
    def to_dict(self) -> Dict[str, Any]:
        """Convert to dictionary for serialization."""
        return {
            "action": self.action.value,
            "strength": self.strength,
            "asset": self.asset,
            "reason": self.reason,
            "indicators": self.indicators,
            "metadata": self.metadata,
        }


class Strategy(ABC):
    """
    Abstract base class for trading strategies.
    
    Strategies define:
    - Required indicators (which indicators to use)
    - Required timeframes (which timeframes to monitor)
    - Evaluation logic (when to buy/sell)
    
    Usage:
        class MyStrategy(Strategy):
            def __init__(self):
                super().__init__("my_strategy")
                self.required_indicators = [("supertrend", "1m"), ("supertrend", "1h")]
            
            def evaluate(self, manager, asset):
                # Get signals
                st_1m = manager.get_signal("supertrend", "1m", asset)
                st_1h = manager.get_signal("supertrend", "1h", asset)
                
                # Logic
                if st_1m.is_bullish and st_1h.is_bullish:
                    return StrategySignal(action=ActionType.BUY, ...)
                return StrategySignal(action=ActionType.HOLD, ...)
    """
    
    def __init__(self, name: str, **params):
        """
        Initialize strategy.
        
        Args:
            name: Unique strategy name
            **params: Strategy-specific parameters
        """
        self.name = name
        self.params = params
        
        # Required indicators: list of (indicator_name, timeframe)
        self.required_indicators: List[tuple] = []
        
        # Required timeframes
        self.required_timeframes: List[str] = []
    
    @abstractmethod
    def evaluate(
        self,
        manager: IndicatorManager,
        asset: str
    ) -> StrategySignal:
        """
        Evaluate strategy and generate signal.
        
        Args:
            manager: IndicatorManager with current indicator states
            asset: Asset symbol to evaluate
        
        Returns:
            StrategySignal with action and details
        """
        pass
    
    def get_required_indicators(self) -> List[tuple]:
        """Get list of required (indicator_name, timeframe) tuples."""
        return self.required_indicators
    
    def validate_indicators(self, manager: IndicatorManager, asset: str) -> bool:
        """
        Check if all required indicators are available.
        
        Args:
            manager: IndicatorManager
            asset: Asset symbol
        
        Returns:
            True if all required indicators have signals
        """
        for name, timeframe in self.required_indicators:
            signal = manager.get_signal(name, timeframe, asset)
            if signal is None:
                return False
        return True
    
    def __repr__(self):
        params_str = ", ".join(f"{k}={v}" for k, v in self.params.items())
        return f"{self.__class__.__name__}({self.name}, {params_str})"
